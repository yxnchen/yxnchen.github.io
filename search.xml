<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Windows平台下单机Spark环境搭建</title>
      <link href="/technique/Windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E5%8D%95%E6%9C%BASpark%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/technique/Windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E5%8D%95%E6%9C%BASpark%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gh-io-1257470807.cos.ap-guangzhou.myqcloud.com/spark-flow.png" alt=""></p><blockquote><p>为了在有限的资源上学习大数据处理与分析技术，借鉴Linux以及部分网上的教程，在Windows10平台搭建Spark环境。本文将简单记录搭建流程以及其中遇到的坑。</p></blockquote><a id="more"></a><p>Spark的部署模式主要有四种：</p><ul><li>Local模式（单机模式）</li><li>Standalone模式（使用Spark自带的简单集群管理器）</li><li>YARN模式（使用YARN作为集群管理器）</li><li>Mesos模式（使用Mesos作为集群管理器）</li></ul><h1 id="安装java"><a class="markdownIt-Anchor" href="#安装java"></a> 安装Java</h1><ul><li>到 <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">Oracle Java</a> 官网下载JDK并安装，安装路径建议直接选择<code>C:\Java</code>，不要安装在<code>Program Files</code>中（路径有空格会导致后面配置Hadoop比较麻烦）<ul><li>添加环境变量<code>JAVA_HOME</code>，值为安装路径，如<code>C:\Java\jdk1.8.0_121</code></li><li>在环境变量<code>Path</code>中增加值：<code>%JAVA_HOME%\bin</code></li><li>打开命令行测试是否安装成功，输入<code>java -version</code>，应该出现如下信息<br><img src="https://gh-io-1257470807.cos.ap-guangzhou.myqcloud.com/java-version.png" alt="命令行查看Java版本信息"></li></ul></li></ul><h1 id="安装spark"><a class="markdownIt-Anchor" href="#安装spark"></a> 安装Spark</h1><ul><li><p>到 <a href="http://spark.apache.org/downloads.html" target="_blank" rel="noopener">Apache Spark</a> 官网下载预编译的压缩文件，解压到某个路径中不含空格的文件夹下，也就成为Spark的安装路径，如<code>D:\spark</code><br><img src="https://gh-io-1257470807.cos.ap-guangzhou.myqcloud.com/spark-dl.png" alt="下载Spark"></p><ul><li>添加环境变量<code>SPARK_HOME</code>，值为安装路径，如<code>D:\spark</code></li><li>在环境变量<code>Path</code>中增加值：<code>%SPARK_HOME%\bin</code>和<code>%SPARK_HOME%\sbin</code></li><li>如果下载的Spark版本<code>&gt;=2.3</code>，建议进一步添加环境变量<code>SPARK_LOCAL_HOSTNAME</code>，值为<code>localhost</code></li><li>进入Spark的配置目录<code>conf</code>，复制一个<code>log4j.properties.template</code>文件并命名为<code>log4j.properties</code>，打开<code>log4j.properties</code>文件，进行如下修改</li></ul>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># log4j.rootCategory=INFO, console</span><br><span class="line">log4j.rootCategory=WARN, console</span><br></pre></td></tr></table></figure><ul><li>同样在Spark的配置目录<code>conf</code>，复制一个<code>spark-env.sh.template</code>文件并命名为<code>spark-env.sh</code>，打开并增加以下一行代码</li></ul>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SPARK_LOCAL_IP = 127.0.0.1</span><br></pre></td></tr></table></figure></li></ul><h1 id="安装hadoop"><a class="markdownIt-Anchor" href="#安装hadoop"></a> 安装Hadoop</h1><ul><li><p>到 <a href="https://hadoop.apache.org/releases.html" target="_blank" rel="noopener">Apache Hadoop</a> 官网下载预编译的压缩包（这里为了更好对应，选择下载2.7版本），解压到某个路径中不含空格的文件夹下，也就称为Hadoop的安装路径，如<code>D:\hadoop</code><br><img src="https://gh-io-1257470807.cos.ap-guangzhou.myqcloud.com/hadoop-dl.png" alt="下载Hadoop（binary版本）"></p><ul><li>添加环境变量<code>HADOOP_HOME</code>，值为安装路径，如<code>D:\hadoop</code></li><li>在环境变量<code>Path</code>中增加值：<code>%HADOOP_HOME%\bin</code>和<code>%HADOOP_HOME%\sbin</code></li><li>进入Hadoop的配置目录<code>etc\hadoop</code>，打开文件<code>hadoop-env.cmd</code>，修改Java的安装路径，如果Java安装在<code>Program Files</code>可以通过设置为<code>PROGRA~1</code>解决空格报错的问题</li></ul>  <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> JAVA_HOME=C:\PROGRA~<span class="number">1</span>\Java\jdk1.<span class="number">8</span>.<span class="number">0</span>_121</span><br></pre></td></tr></table></figure><ul><li>下载对应版本的 <a href="https://github.com/steveloughran/winutils" target="_blank" rel="noopener">winutils</a>，把下载到的<code>bin</code>文件夹覆盖到Hadoop安装目录的<code>bin</code>文件夹，确保其中含有<code>winutils.exe</code>文件</li><li>新建<code>tmp\hive</code>文件夹，如<code>C:\tmp\hive</code>，命令行导航到Hadoop的<code>bin</code>目录，执行以下授权操作</li></ul>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">winutils.exe chmod -R 777 C:\tmp\hive</span><br></pre></td></tr></table></figure><ul><li>最后在命令行输入<code>hadoop version</code>测试是否安装成功<br><img src="https://gh-io-1257470807.cos.ap-guangzhou.myqcloud.com/hadoop-version.png" alt="验证Hadoop安装成功"></li></ul></li></ul><h1 id="验证spark安装成功"><a class="markdownIt-Anchor" href="#验证spark安装成功"></a> 验证Spark安装成功</h1><ul><li>打开命令行，运行<code>spark-shell</code>，应该输入如下内容<br><img src="https://gh-io-1257470807.cos.ap-guangzhou.myqcloud.com/spark-shell.png" alt="验证Spark安装成功"></li><li>此时进入<code>localhost:4040</code>可以看到Spark的Web界面<br><img src="https://gh-io-1257470807.cos.ap-guangzhou.myqcloud.com/spark-WebUI.png" alt=""></li></ul><h1 id="使用spark开发第一个程序"><a class="markdownIt-Anchor" href="#使用spark开发第一个程序"></a> 使用Spark开发第一个程序</h1><h2 id="python"><a class="markdownIt-Anchor" href="#python"></a> Python</h2><h3 id="安装pyspark"><a class="markdownIt-Anchor" href="#安装pyspark"></a> 安装PySpark</h3><ul><li>把Spark安装路径下的<code>python\pyspark</code>文件夹复制到系统Python的包文件夹下，例如在Anaconda环境中，复制到<code>D:\Anaconda3\Lib\site-packages</code>目录下</li><li>安装Python包<code>py4j</code>，在命令行运行<code>pip install py4j</code></li><li>验证PySpark配置成功，在命令行输入<code>pyspark</code>，应该输出如下内容<br><img src="https://gh-io-1257470807.cos.ap-guangzhou.myqcloud.com/pyspark.png" alt="验证PySpark环境可用"></li></ul><h3 id="在pycharm中使用pyspark"><a class="markdownIt-Anchor" href="#在pycharm中使用pyspark"></a> 在PyCharm中使用PySpark</h3><blockquote><p>下面以一个经典的词频统计（Word Count）程序为例，学习PySpark的使用，词频统计是一个很经典的分布式程序，这里用到中文分词库jieba，去除停用词再进行计数</p></blockquote><ul><li>新建Python工程，并新建脚本<code>wordcount.py</code></li><li>在网上随便找一篇新闻报道，复制内容到文本文件<code>news.txt</code>，记住其路径</li><li>到GitHub上搜索中文停用词资源，如从 <a href="https://github.com/stopwords-iso/stopwords-zh/blob/master/stopwords-zh.txt" target="_blank" rel="noopener">https://github.com/stopwords-iso/stopwords-zh/blob/master/stopwords-zh.txt</a> 下载得到<code>stopwords-zh.txt</code></li><li>打开脚本并输入如下代码</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 从pyspark.context模块导入SparkContext</span></span><br><span class="line"><span class="keyword">from</span> pyspark.context <span class="keyword">import</span> SparkContext</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个SparkContext，用于连接Spark集群</span></span><br><span class="line"><span class="comment"># 第一个参数“local”表示以本地模式加载集群</span></span><br><span class="line"><span class="comment"># 第二个参数“WordCount”表示appName，不能有空格</span></span><br><span class="line">spark = SparkContext(<span class="string">"local"</span>, <span class="string">"WordCount"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据，创建弹性式分布数据集（RDD）</span></span><br><span class="line">data = spark.textFile(<span class="string">r"path/to/news.txt"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取中文停用词</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r'path/to/stopwords-zh.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    s = f.readline()</span><br><span class="line">stop = [i.replace(<span class="string">'\n'</span>,<span class="string">''</span>) <span class="keyword">for</span> i <span class="keyword">in</span> s]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分词并统计词频</span></span><br><span class="line">data = data.flatMap(<span class="keyword">lambda</span> line: jieba.cut(line,cut_all=<span class="keyword">False</span>)).\</span><br><span class="line">    filter(<span class="keyword">lambda</span> w: w <span class="keyword">not</span> <span class="keyword">in</span> stop).\</span><br><span class="line">    map(<span class="keyword">lambda</span> w: (w,<span class="number">1</span>)).\</span><br><span class="line">    reduceByKey(<span class="keyword">lambda</span> w0, w1: w0 + w1).\</span><br><span class="line">    sortBy(<span class="keyword">lambda</span> x: x[<span class="number">1</span>], ascending=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出前100个高频词汇</span></span><br><span class="line">print(data.take(<span class="number">100</span>))</span><br></pre></td></tr></table></figure><ul><li><p>设置程序运行配置，打开<code>Run-&gt;Edit Configuration</code>，按照如下图所示内容新建一个配置，其中环境变量必须加入<code>SPARK_HOME</code>、<code>HADOOP_HOME</code>以及<code>SPARK_LOCAL_HOSTNAME</code><br><img src="https://gh-io-1257470807.cos.ap-guangzhou.myqcloud.com/spark-configuration.png" alt="设置PyCharm运行配置"></p></li><li><p>运行程序，最后输出前100个高频词语<br><img src="https://gh-io-1257470807.cos.ap-guangzhou.myqcloud.com/wordcount.png" alt="WordCount程序输出"></p></li></ul><h3 id="程序提交到spark运行"><a class="markdownIt-Anchor" href="#程序提交到spark运行"></a> 程序提交到Spark运行</h3><p>上述词频统计代码也可以直接提交到Spark运行，方法如下：</p><ul><li>打开命令行，导航到Spark的安装目录，执行提交任务命令：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd D:/spark</span><br><span class="line">./bin/spark-submit /path/to/wordcount.py</span><br></pre></td></tr></table></figure><ul><li>最后输出类似的执行结果<br><img src="https://gh-io-1257470807.cos.ap-guangzhou.myqcloud.com/wordcount-shell.png" alt="提交Spark任务，并输出运行结果"></li></ul><h2 id="scala-java"><a class="markdownIt-Anchor" href="#scala-java"></a> Scala &amp; Java</h2><h3 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h3><ul><li>在 IntelliJ IDEA 新建一个Maven工程</li><li>在项目的Maven配置文件<code>pom.xml</code>中加入Spark-core依赖，根据安装的Spark版本到 <a href="https://mvnrepository.com/artifact/org.apache.spark/spark-core" target="_blank" rel="noopener">Maven Repository</a> 仓库找到对应的Maven依赖文本，如：</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.spark/spark-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>打开工程目录下的主程序文件，通常为<code>./src/main/java/App.java</code>，编写词频统计代码</li><li>下面将以两种形式进行编写，Java Lambda的代码风格接近Python，易于阅读；而Java原生模式则稍显复杂</li></ul><h4 id="java-lambda"><a class="markdownIt-Anchor" href="#java-lambda"></a> Java Lambda</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.SparkConf;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.JavaPairRDD;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.JavaRDD;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.JavaSparkContext;</span><br><span class="line"><span class="keyword">import</span> scala.Tuple2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Word count!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Spark实例</span></span><br><span class="line">        SparkConf conf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"WordCount"</span>).setMaster(<span class="string">"local"</span>);</span><br><span class="line">        JavaSparkContext jsc = <span class="keyword">new</span> JavaSparkContext(conf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据，这里是一个关于Spark介绍的文本</span></span><br><span class="line">        String filename = <span class="string">"path/to/spark.txt"</span>;</span><br><span class="line">        JavaRDD&lt;String&gt; data = jsc.textFile(filename);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切割压平</span></span><br><span class="line">        JavaRDD&lt;String&gt; dataMap = data.flatMap(t -&gt; Arrays.asList(t.split(<span class="string">" "</span>)).iterator());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组合成元组</span></span><br><span class="line">        JavaPairRDD&lt;String, Integer&gt; dataPair = dataMap.mapToPair(t -&gt; <span class="keyword">new</span> Tuple2&lt;&gt;(t,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分组聚合</span></span><br><span class="line">        JavaPairRDD&lt;String, Integer&gt; dataAgg = dataPair.reduceByKey((w1,w2) -&gt; w1+w2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换key，再排序</span></span><br><span class="line">        JavaPairRDD&lt;Integer, String&gt; dataSwap = dataAgg.mapToPair(tp -&gt; tp.swap());</span><br><span class="line">        JavaPairRDD&lt;Integer, String&gt; dataSort = dataSwap.sortByKey(<span class="keyword">false</span>);</span><br><span class="line">        JavaPairRDD&lt;String, Integer&gt; result = dataSort.mapToPair(tp -&gt; tp.swap());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存结果，saveAsTextFile()方法是将RDD写到本地，根据执行task的多少生成多少个文件</span></span><br><span class="line">        <span class="comment">// 输出目录不能预先存在，否则报错</span></span><br><span class="line">        result.saveAsTextFile(<span class="string">"path/to/spark_count"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出第一个</span></span><br><span class="line">        List&lt;Tuple2&lt;String, Integer&gt;&gt; resList = result.collect();</span><br><span class="line">        <span class="keyword">for</span> (Tuple2&lt;String, Integer&gt; tp: resList)&#123;</span><br><span class="line">            System.out.println(tp._1+<span class="string">"\t"</span>+tp._2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jsc.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后打开输出结果文件夹的<code>part-00000</code>文件，输出各个单词的统计数：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(Spark,7)</span><br><span class="line">(and,7)</span><br><span class="line">(the,5)</span><br><span class="line">(Apache,5)</span><br><span class="line">(of,4)</span><br><span class="line">(for,3)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="java-原生模式"><a class="markdownIt-Anchor" href="#java-原生模式"></a> Java 原生模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.SparkConf;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.JavaPairRDD;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.JavaRDD;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.JavaSparkContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.function.FlatMapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.function.Function2;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.function.PairFunction;</span><br><span class="line"><span class="keyword">import</span> scala.Tuple2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Word count!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Spark实例</span></span><br><span class="line">        SparkConf conf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"WordCount"</span>).setMaster(<span class="string">"local"</span>);</span><br><span class="line">        JavaSparkContext jsc = <span class="keyword">new</span> JavaSparkContext(conf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据，这里是一个关于Spark介绍的文本</span></span><br><span class="line">        String filename = <span class="string">"path/to/spark.txt"</span>;</span><br><span class="line">        JavaRDD&lt;String&gt; data = jsc.textFile(filename);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切割压平</span></span><br><span class="line">        JavaRDD&lt;String&gt; dataMap = data.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">call</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Arrays.asList(s.split(<span class="string">" "</span>)).iterator();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组合成元组</span></span><br><span class="line">        JavaPairRDD&lt;String, Integer&gt; dataPair = dataMap.mapToPair(<span class="keyword">new</span> PairFunction&lt;String, String, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">call</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(s,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分组聚合</span></span><br><span class="line">        JavaPairRDD&lt;String, Integer&gt; dataAgg = dataPair.reduceByKey(<span class="keyword">new</span> Function2&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(Integer w1, Integer w2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> w1 + w2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换key，再排序</span></span><br><span class="line">        JavaPairRDD&lt;Integer, String&gt; dataSwap = dataAgg.mapToPair(<span class="keyword">new</span> PairFunction&lt;Tuple2&lt;String, Integer&gt;, Integer, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Tuple2&lt;Integer, String&gt; <span class="title">call</span><span class="params">(Tuple2&lt;String, Integer&gt; tp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> tp.swap();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        JavaPairRDD&lt;Integer, String&gt; dataSort = dataSwap.sortByKey(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        JavaPairRDD&lt;String, Integer&gt; result = dataSort.mapToPair(<span class="keyword">new</span> PairFunction&lt;Tuple2&lt;Integer, String&gt;, String, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">call</span><span class="params">(Tuple2&lt;Integer, String&gt; tp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> tp.swap();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存结果，saveAsTextFile()方法是将RDD写到本地，根据执行task的多少生成多少个文件</span></span><br><span class="line">        <span class="comment">// 输出目录不能预先存在，否则报错</span></span><br><span class="line">        result.saveAsTextFile(<span class="string">"path/to/spark_count"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出第一个</span></span><br><span class="line">        List&lt;Tuple2&lt;String, Integer&gt;&gt; resList = result.collect();</span><br><span class="line">        <span class="keyword">for</span> (Tuple2&lt;String, Integer&gt; tp: resList)&#123;</span><br><span class="line">            System.out.println(tp._1+<span class="string">"\t"</span>+tp._2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jsc.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后结果与上面情况类似</li></ul><h3 id="scala"><a class="markdownIt-Anchor" href="#scala"></a> Scala</h3><p>（待更新）</p>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Big-Data </tag>
            
            <tag> Hadoop </tag>
            
            <tag> Spark </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的Windows装机必备应用</title>
      <link href="/technique/%E6%88%91%E7%9A%84Windows%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87%E5%BA%94%E7%94%A8/"/>
      <url>/technique/%E6%88%91%E7%9A%84Windows%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gh-io-1257470807.cos.ap-guangzhou.myqcloud.com/windows10-laptop.jpg" alt=""></p><blockquote><p>本文记录本人使用Windows的必备软件工具，以及在使用中的设置习惯。</p></blockquote><a id="more"></a><h1 id="uwp应用"><a class="markdownIt-Anchor" href="#uwp应用"></a> UWP应用</h1><ul><li><code>网易云音乐</code></li><li><code>OneNote</code></li><li><code>Drawboard PDF</code></li><li><code>Microsoft To-Do</code></li><li><code>Termius</code></li></ul><h1 id="网络及通讯"><a class="markdownIt-Anchor" href="#网络及通讯"></a> 网络及通讯</h1><ul><li><p><code>Chrome</code>: 利用 <a href="https://www.google.com/chrome/index.html?platform=win64&amp;standalone=1" target="_blank" rel="noopener">https://www.google.com/chrome/index.html?platform=win64&amp;standalone=1</a> 下载最新64位离线安装包</p><ul><li>SwitchyOmega</li><li>JSONView</li><li>Tampermonkey</li><li>OneTab</li><li>Clip to OneNote</li><li>uBlock Origin</li><li>Enhanced GitHub</li><li>Reggy</li><li>Color by Fardos</li><li>View Image</li><li>Better History</li><li>Octotree</li></ul></li><li><p><code>迅雷U享版</code>: <a href="http://u.xunlei.com/" target="_blank" rel="noopener">http://u.xunlei.com/</a></p></li><li><p><code>坚果云</code>: <a href="https://www.jianguoyun.com/" target="_blank" rel="noopener">https://www.jianguoyun.com/</a></p></li><li><p><code>Xshell6/Xftp6</code>: <a href="https://www.netsarang.com/en/free-for-home-school/" target="_blank" rel="noopener">https://www.netsarang.com/en/free-for-home-school/</a></p></li></ul><h1 id="编辑器"><a class="markdownIt-Anchor" href="#编辑器"></a> 编辑器</h1><ul><li><p><code>Sublime Text 3</code>: <a href="https://www.sublimetext.com/" target="_blank" rel="noopener">https://www.sublimetext.com/</a></p><ul><li>Package Control: <a href="https://packagecontrol.io/" target="_blank" rel="noopener">https://packagecontrol.io/</a></li><li>channel_v3_daily: 解决 Sublime Text 3 拓展包源无法访问问题 <a href="https://github.com/HBLong/channel_v3_daily" target="_blank" rel="noopener">https://github.com/HBLong/channel_v3_daily</a></li><li>Dracula Color Scheme</li><li>Boxy Theme: 第三方备份地址 <a href="https://github.com/balthild/boxy-theme-backup" target="_blank" rel="noopener">https://github.com/balthild/boxy-theme-backup</a></li><li>A File Icon</li><li>LaTeXTools与LaTeX-cwl</li></ul></li><li><p><code>Visual Studio Code</code>: <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></p><ul><li>sftp</li><li>Dracula Official</li><li>Excel Viewer</li><li>LaTeX Workshop</li><li>Markdown Preview Enhanced</li><li>Prettify JSON</li><li>REST Client</li><li>VSCode Map Preview</li></ul></li><li><p><code>Typora</code>: <a href="https://typora.io/" target="_blank" rel="noopener">https://typora.io/</a></p><ul><li>Ursine Theme</li></ul></li></ul><h1 id="查看器"><a class="markdownIt-Anchor" href="#查看器"></a> 查看器</h1><ul><li><code>SumatraPDF</code>: <a href="https://www.sumatrapdfreader.org/free-pdf-reader.html" target="_blank" rel="noopener">https://www.sumatrapdfreader.org/free-pdf-reader.html</a></li><li><code>Potplayer</code>: <a href="http://potplayer.daum.net/?lang=zh_CN" target="_blank" rel="noopener">http://potplayer.daum.net/?lang=zh_CN</a></li><li><code>Office 365</code>: <a href="https://www.office.com/" target="_blank" rel="noopener">https://www.office.com/</a></li></ul><h1 id="实用工具"><a class="markdownIt-Anchor" href="#实用工具"></a> 实用工具</h1><ul><li><code>Bandizip</code>: <a href="https://en.bandisoft.com/bandizip/" target="_blank" rel="noopener">https://en.bandisoft.com/bandizip/</a></li><li><code>Everything</code>: <a href="https://www.voidtools.com/" target="_blank" rel="noopener">https://www.voidtools.com/</a></li><li><code>Wox</code>: <a href="http://www.wox.one/" target="_blank" rel="noopener">http://www.wox.one/</a></li><li><code>UltraISO</code>: <a href="https://cn.ultraiso.net/" target="_blank" rel="noopener">https://cn.ultraiso.net/</a></li><li><code>Rufus</code>: <a href="https://rufus.ie/" target="_blank" rel="noopener">https://rufus.ie/</a></li></ul><h1 id="语言环境"><a class="markdownIt-Anchor" href="#语言环境"></a> 语言环境</h1><ul><li><code>Python</code>: <a href="https://repo.continuum.io/archive/" target="_blank" rel="noopener">https://repo.continuum.io/archive/</a><ul><li>版本对应关系: <a href="https://blog.csdn.net/yuejisuo1948/article/details/81043823" target="_blank" rel="noopener">https://blog.csdn.net/yuejisuo1948/article/details/81043823</a></li></ul></li><li><code>C/C++</code>: <a href="http://www.mingw.org/" target="_blank" rel="noopener">http://www.mingw.org/</a><ul><li>使用参考 <a href="https://www.cnblogs.com/iwideal/p/7647243.html" target="_blank" rel="noopener">https://www.cnblogs.com/iwideal/p/7647243.html</a></li></ul></li><li><code>Java8</code>: <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li><li><code>Node</code>: <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a></li></ul><h1 id="ide"><a class="markdownIt-Anchor" href="#ide"></a> IDE</h1><ul><li><code>JetBrains (Pycharm, IntelliJ IDEA, DataGrip)</code>: <a href="http://www.jetbrains.com/" target="_blank" rel="noopener">http://www.jetbrains.com/</a></li><li><code>Visual Studio Community</code>: <a href="https://visualstudio.microsoft.com/vs/" target="_blank" rel="noopener">https://visualstudio.microsoft.com/vs/</a></li></ul><h1 id="cli"><a class="markdownIt-Anchor" href="#cli"></a> CLI</h1><ul><li><code>Git</code>: <a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></li><li><code>FluentTerminal</code>: <a href="https://github.com/felixse/FluentTerminal" target="_blank" rel="noopener">https://github.com/felixse/FluentTerminal</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Software </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署ShareLaTeX并简单配置中文环境</title>
      <link href="/technique/Docker%E9%83%A8%E7%BD%B2ShareLaTeX%E5%B9%B6%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/"/>
      <url>/technique/Docker%E9%83%A8%E7%BD%B2ShareLaTeX%E5%B9%B6%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gh-io-1257470807.cos.ap-guangzhou.myqcloud.com/sharelatex.png" alt=""></p><blockquote><p>由于某些原因，国内访问ShareLaTeX或Overleaf网站速度特别慢而且经常掉线，科研环境十分不友好，因此有了自己搭建ShareLaTeX服务打算，且其支持Docker容器化部署，安装过程比较容易。本文记录了在实验室内网环境下利用Docker搭建ShareLaTeX服务的过程，并进行中文环境配置。</p></blockquote><a id="more"></a><h1 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h1><p>系统与Docker环境安装同上篇<a href="https://yxnchen.github.io/technique/Docker%E9%83%A8%E7%BD%B2GitLab%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/">Docker部署GitLab并实现基本配置</a>，然后继续按照<a href="https://legacy.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="noopener">教程</a>安装<code>docker-compose</code>组件。</p><h1 id="安装并配置sharelatex"><a class="markdownIt-Anchor" href="#安装并配置sharelatex"></a> 安装并配置ShareLaTeX</h1><blockquote><p>由于ShareLaTeX的安装依赖于MongoDB和Redis，因此本文将使用官方向导建议使用<code>docker-compose</code>快速部署ShareLaTeX</p></blockquote><ul><li><p>拉取最新的ShareLaTeX镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull sharelatex/sharelatex</span><br></pre></td></tr></table></figure></li><li><p>下载<code>docker-compose.yml</code>文件，并进行配置，见<a href="https://github.com/sharelatex/sharelatex/wiki/Quick-Start-Guide#using-a-compose-file" target="_blank" rel="noopener">Quick Start Guide</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir -p ~/sharelatex          <span class="comment"># 在用户目录下创建一个sharelatex文件夹</span></span><br><span class="line">$ <span class="built_in">cd</span> ~/sharelatex                <span class="comment"># 进入sharelatex文件夹</span></span><br><span class="line">$ curl -O https://raw.githubusercontent.com/sharelatex/sharelatex/master/docker-compose.yml                      <span class="comment"># 下载官方的docker-compose.yml配置文件</span></span><br><span class="line">$ sudo vi docker-compose.yml     <span class="comment"># 使用vi修改配置文件</span></span><br></pre></td></tr></table></figure></li><li><p>需要配置的项</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 避免端口重复</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">5000</span><span class="string">:80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改本地挂载目录</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">/home/docker/sharelatex:/var/lib/sharelatex</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加升级texlive需要的环境变量，主要是添加2018目录到2017前面，目的是为了防止后面安装完整版texlive时出现错误</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">PATH:</span> <span class="string">/usr/localsbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/texlive/2018/bin/x86_64-linux:/usr/local/texlive/2017/bin/x86_64-linux</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面选项设置ShareLaTeX的显示样式</span></span><br><span class="line"><span class="attr">SHARELATEX_APP_NAME:</span> <span class="string">Our</span> <span class="string">ShareLaTeX</span></span><br><span class="line"><span class="attr">SHARELATEX_NAV_TITLE:</span> <span class="string">Our</span> <span class="string">ShareLaTeX</span> <span class="string">Instance</span></span><br><span class="line"><span class="attr">SHARELATEX_HEADER_IMAGE_URL:</span> <span class="attr">http://somewhere.com/mylogo.png</span></span><br><span class="line"><span class="attr">SHARELATEX_LEFT_FOOTER:</span> <span class="string">'[&#123;"text": "Powered by &lt;a href=\"https://www.sharelatex.com\"&gt;ShareLaTeX&lt;/a&gt; 2016"&#125;,&#123;"text": "Another page I want to link to can be found &lt;a href=\"here\"&gt;here&lt;/a&gt;"&#125; ]'</span></span><br><span class="line"><span class="attr">SHARELATEX_RIGHT_FOOTER:</span> <span class="string">'[&#123;"text": "Hello I am on the Right"&#125; ]'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改mongo和redis的本地挂载目录</span></span><br><span class="line"><span class="comment"># mongo</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">/home/docker/mongo_data:/data/db</span></span><br><span class="line"><span class="comment"># redis</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">/home/docker/redis_data:/data</span></span><br></pre></td></tr></table></figure></li><li><p>创建并运行ShareLaTeX容器，启动后不要着急进入网站</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在sharelatex目录下</span></span><br><span class="line">$ docker-compose up -d</span><br></pre></td></tr></table></figure></li><li><p>升级并安装完整版texlive，<a href="https://www.tug.org/texlive/upgrade.html" target="_blank" rel="noopener">官方教程</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入容器的命令行（sharelatex容器本质上是一个Ubuntu）</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it sharelatex bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入texlive默认安装目录</span></span><br><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/texlive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制2017文件夹为2018</span></span><br><span class="line">$ cp -a 2017 2018</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载并运行升级脚本</span></span><br><span class="line">$ wget http://mirror.ctan.org/systems/texlive/tlnet/update-tlmgr-latest.sh</span><br><span class="line">$ sh update-tlmgr-latest.sh -- --upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更换texlive的下载源，例如国内的清华源</span></span><br><span class="line">$ tlmgr option repository https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级tlmgr</span></span><br><span class="line">$ tlmgr update --self --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新字体缓存（好像没成功，但是不影响下面操作）</span></span><br><span class="line">$ luaotfload-tool -fu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完整版texlive（漫长的等待，不要让shell断开）</span></span><br><span class="line">$ tlmgr install scheme-full</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推出sharelatex的命令行界面，并重启sharelatex容器</span></span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line">$ docker restart sharelatex</span><br></pre></td></tr></table></figure></li><li><p>使用ShareLaTeX</p><p>进入浏览器访问<code>http://192.168.8.21:5000/launchpad</code>，根据提示创建Admin用户。</p></li></ul><h1 id="配置中文写作环境"><a class="markdownIt-Anchor" href="#配置中文写作环境"></a> 配置中文写作环境</h1><blockquote><p>下载的sharelatex镜像里面默认是没有安装xfont和中文字体的，因此无法渲染中文文档，必须安装所需的中文字体，这里以Windows下常用字体和Adobe Song Std为例。原教程见<a href="https://blog.csdn.net/hello_percy/article/details/72147414" target="_blank" rel="noopener">ArchLinux 部署ShareLaTex并且配置中文支持</a>。</p></blockquote><ul><li><p>将Windows字体库（即目录<code>C:\windows\fonts</code>）上传到host机，如果Windows安装了Git可以使用<code>scp</code>命令直接上传</p></li><li><p>在host机下把<code>fonts</code>目录打包并传到sharelatex容器中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入fonts目录</span></span><br><span class="line">$ <span class="built_in">cd</span> fonts/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除其中的.fon字体文件（该种格式文件在后面建立字体目录时会报错），只保留TrueType和OpenType字体，即.ttf和.otf</span></span><br><span class="line"><span class="comment"># 一般地，如果只需要其中特定的中文字体，只需要上传需要的字体即可</span></span><br><span class="line">$ rm -r *.fon</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回上层目录并打包</span></span><br><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line">$ tar -zcvf winfonts.tar.gz fonts/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把压缩文件传到sharelatex容器的root目录下</span></span><br><span class="line">$ docker cp winfonts.tar.gz sharelatex:/root</span><br></pre></td></tr></table></figure></li><li><p>在容器中安装Windows字体</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入容器的命令行界面</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it sharelatex bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过安装wqy字体同时安装xfont工具</span></span><br><span class="line">$ apt-get install xfonts-wqy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入root目录，解压winfonts.tar.gz，并剪切到系统字体目录下</span></span><br><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ tar -zxvf winfonts.tar.gz</span><br><span class="line">$ mv winfonts /usr/share/fonts/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入字体目录安装字体</span></span><br><span class="line">$ <span class="built_in">cd</span> /usr/share/fonts/winfonts</span><br><span class="line">$ mkfontscale</span><br><span class="line">$ mkfontdir</span><br><span class="line">$ <span class="built_in">fc</span>-cache -fv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查确认中文字体安装成功</span></span><br><span class="line">$ <span class="built_in">fc</span>-list :lang=zh-cn</span><br></pre></td></tr></table></figure></li><li><p>回到ShareLaTeX网站，创建一个新项目，使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mtext>TeX</mtext></mrow><annotation encoding="application/x-tex">C\TeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span>宏集和XeLaTeX编译器，即可生成中文pdf。（详见<a href="http://mirrors.ibiblio.org/CTAN/language/chinese/ctex/ctex.pdf" target="_blank" rel="noopener"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mtext>TeX</mtext></mrow><annotation encoding="application/x-tex">C\TeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span>宏集手册</a>）</p></li><li><p>因为学校论文的需要，有时需要其他中文字体，例如Adobe宋体，其安装流程与上述基本一致。（PS：在GitHub上可以找到公开的Adobe Song Std字体，涉及版权这里不放链接）</p></li></ul><h1 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h1><ol><li><a href="https://blog.csdn.net/sofair/article/details/80994960" target="_blank" rel="noopener">在本地部署ShareLatex服务</a></li><li><a href="https://haoyu.love/blog640.html" target="_blank" rel="noopener">本地部署 ShareLatex</a></li><li><a href="https://blog.csdn.net/hello_percy/article/details/72147414" target="_blank" rel="noopener">ArchLinux 部署ShareLaTex并且配置中文支持</a></li><li><a href="https://www.scaleway.com/docs/installing-sharelatex-ubuntu/" target="_blank" rel="noopener">Installing ShareLaTeX</a></li><li><a href="https://github.com/sharelatex/sharelatex/wiki/Quick-Start-Guide" target="_blank" rel="noopener">Quick Start Guide</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
            <tag> ShareLaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署GitLab并实现基本配置</title>
      <link href="/technique/Docker%E9%83%A8%E7%BD%B2GitLab%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
      <url>/technique/Docker%E9%83%A8%E7%BD%B2GitLab%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gh-io-1257470807.cos.ap-guangzhou.myqcloud.com/docker-build-push-gitlab-ci.png" alt=""></p><blockquote><p>本地GitLab的安装需要部署各种依赖和其他服务，费时且麻烦，而直接使用Docker进行容器化部署则省时简单，只要运行一行命令即可使用。本文记录了在实验室内网环境下利用Docker搭建源码托管工具GitLab，并列出一些必要的个性化配置项。</p></blockquote><a id="more"></a><h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2><h3 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h3><p>由于Ubuntu系统在Docker环境下兼容性更高，选择了 <code>Ubuntu 18.04 LTS</code> 作为操作系统环境。</p><h3 id="安装docker"><a class="markdownIt-Anchor" href="#安装docker"></a> 安装Docker</h3><p>Docker环境的安装十分简单，在这里不详述，根据<a href="https://legacy.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="noopener">Docker —— 从入门到实践</a>选择对应操作系统的安装教程即可。</p><h2 id="安装gitlab-ce"><a class="markdownIt-Anchor" href="#安装gitlab-ce"></a> 安装GitLab-ce</h2><blockquote><p>GitLab的安装可以直接<code>run</code>，或者通过<code>docker-compose</code>文件指定安装流程，这里使用前者进行快速简单安装，后者后续更新。</p></blockquote><ul><li><p>拉取GitLab-ce镜像，查看镜像信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull gitlab/gitlab-ce</span><br><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure></li><li><p>创建并启动一个GitLab容器，<code>:</code>后的内容不要修改</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ GITLAB_HOME = /home/docker/gitlab     <span class="comment"># 建立gitlab本地目录</span></span><br><span class="line">$ docker run -d \</span><br><span class="line">--hostname gitlab.example.com\          <span class="comment"># 指定容器域名,创建镜像仓库用</span></span><br><span class="line">-p 8443:443 \                           <span class="comment"># 容器443端口映射到主机8443端口(https)</span></span><br><span class="line">-p 8080:80 \                            <span class="comment"># 容器80端口映射到主机8080端口(http)</span></span><br><span class="line">-p 2222:22 \                            <span class="comment"># 容器22端口映射到主机2222端口(ssh)</span></span><br><span class="line">--name gitlab \                         <span class="comment"># 容器名称</span></span><br><span class="line">--restart always \                      <span class="comment"># 容器退出后自动重启</span></span><br><span class="line">-v <span class="variable">$GITLAB_HOME</span>/config:/etc/gitlab \    <span class="comment"># 挂载本地目录到容器配置目录</span></span><br><span class="line">-v <span class="variable">$GITLAB_HOME</span>/logs:/var/<span class="built_in">log</span>/gitlab \  <span class="comment"># 挂载本地目录到容器日志目录</span></span><br><span class="line">-v <span class="variable">$GITLAB_HOME</span>/data:/var/opt/gitlab \  <span class="comment"># 挂载本地目录到容器数据目录</span></span><br><span class="line">gitlab/gitlab-ce:latest                 <span class="comment"># 使用的镜像:版本</span></span><br></pre></td></tr></table></figure></li><li><p>查看容器运行情况，出现gitlab运行信息表明启动成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container ls</span><br></pre></td></tr></table></figure></li><li><p>浏览器进入<code>http://192.168.8.21:8080</code>，使用<code>root</code>账户登录并设置密码即可进入管理员界面</p></li></ul><h2 id="配置gitlab"><a class="markdownIt-Anchor" href="#配置gitlab"></a> 配置GitLab</h2><blockquote><p>可参考官方配置说明<a href="https://docs.gitlab.com/omnibus/settings/configuration.html" target="_blank" rel="noopener">文档</a>，本地配置文件在<code>$GITLAB_HOME/config/gitlab.rb</code></p></blockquote><h3 id="备份默认配置文件"><a class="markdownIt-Anchor" href="#备份默认配置文件"></a> 备份默认配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /home/docker/gitlab/config</span><br><span class="line">$ cp gitlab.rb gitlab.rb.default</span><br></pre></td></tr></table></figure><h3 id="修改与重载配置"><a class="markdownIt-Anchor" href="#修改与重载配置"></a> 修改与重载配置</h3><ul><li><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo vi /home/docker/gitlab/config</span><br></pre></td></tr></table></figure></li><li><p>重载配置</p><p>在gitlab容器内重载</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -t gitlab gitlab-ctl reconfigure</span><br><span class="line">$ docker <span class="built_in">exec</span> -t gitlab gitlab-ctl restart</span><br></pre></td></tr></table></figure><p>或直接重启容器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker restart gitlab</span><br></pre></td></tr></table></figure></li></ul><h3 id="常用配置选项"><a class="markdownIt-Anchor" href="#常用配置选项"></a> 常用配置选项</h3><ul><li><p>配置web请求地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">external_url &apos;http://192.168.8.21&apos;</span><br></pre></td></tr></table></figure></li><li><p>设置时区</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab_rails[&apos;time_zone&apos;] = &apos;Asia/Shanghai&apos;</span><br></pre></td></tr></table></figure></li><li><p>允许自定义头像，去掉注释<code>#</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab_rails[&apos;gravatar_plain_url&apos;] = &apos;http://www.gravatar.com/avatar/%&#123;hash&#125;?s=%&#123;size&#125;&amp;d=identicon&apos;</span><br></pre></td></tr></table></figure></li><li><p>由于设置了端口映射，设置如下选项使得网页端显示正常可用的ssh地址，如“ssh://git@192.168.8.21:2222/xxx/xxx.git”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab_rails[&apos;gitlab_shell_ssh_port&apos;] = 2222</span><br></pre></td></tr></table></figure></li><li><p>在实验室内网环境下，关闭GitLab的CI/CD功能，详细见<a href="https://docs.gitlab.com/ce/ci/enable_or_disable_ci.html" target="_blank" rel="noopener">官方说明</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab_rails[&apos;gitlab_default_projects_features_builds&apos;] = false</span><br></pre></td></tr></table></figure></li><li><p>设置GitLab备份路径</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab_rails[&apos;manage_backup_path&apos;] = true</span><br><span class="line">gitlab_rails[&apos;backup_path&apos;] = &quot;/var/opt/gitlab/backups&quot;</span><br></pre></td></tr></table></figure></li><li><p>配置邮箱服务，可以参考<a href="http://blog.51cto.com/8456082/2090423" target="_blank" rel="noopener">连接</a></p></li><li><p>添加SSL证书支持HTTPS，可以参考<a href="https://blog.csdn.net/u014258541/article/details/79224492/" target="_blank" rel="noopener">连接</a>，由于使用自签名证书Chrome会拦截，所以没有弄</p></li></ul><h2 id="更新gitlab"><a class="markdownIt-Anchor" href="#更新gitlab"></a> 更新GitLab</h2><ul><li><p>拉取最新的GitLab-ce镜像，然后停止并删除当前的GitLab容器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker stop gitlab</span><br><span class="line">$ docker rm gitlab</span><br></pre></td></tr></table></figure></li><li><p>重启创建并启动GitLab容器，使用同样的配置和volume参数即可，GitLab会自动读取这些配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">--hostname gitlab.example.com\</span><br><span class="line">-p 8443:443 \ </span><br><span class="line">-p 8080:80 \ </span><br><span class="line">-p 2222:22 \</span><br><span class="line">--name gitlab \</span><br><span class="line">--restart always \</span><br><span class="line">-v <span class="variable">$GITLAB_HOME</span>/config:/etc/gitlab \</span><br><span class="line">-v <span class="variable">$GITLAB_HOME</span>/logs:/var/<span class="built_in">log</span>/gitlab \</span><br><span class="line">-v <span class="variable">$GITLAB_HOME</span>/data:/var/opt/gitlab \</span><br><span class="line">gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2><ol><li><a href="http://blog.51cto.com/8456082/2090423" target="_blank" rel="noopener">通过docker安装Gitlab</a></li><li><a href="https://www.cnblogs.com/int32bit/p/5310382.html" target="_blank" rel="noopener">使用Docker部署Gitlab</a></li><li><a href="https://blog.csdn.net/u014258541/article/details/79224492/" target="_blank" rel="noopener">docker部署gitLab</a></li><li><a href="https://docs.gitlab.com/ce/ci/enable_or_disable_ci.html" target="_blank" rel="noopener">How to enable or disable GitLab CI/CD</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
            <tag> GitLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝叶斯泊松分解变分推断笔记</title>
      <link href="/research/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%8A%E6%9D%BE%E5%88%86%E8%A7%A3%E5%8F%98%E5%88%86%E6%8E%A8%E6%96%AD%E7%AC%94%E8%AE%B0/"/>
      <url>/research/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%8A%E6%9D%BE%E5%88%86%E8%A7%A3%E5%8F%98%E5%88%86%E6%8E%A8%E6%96%AD%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="贝叶斯泊松分解"><a class="markdownIt-Anchor" href="#贝叶斯泊松分解"></a> 贝叶斯泊松分解</h2><h3 id="一般形式"><a class="markdownIt-Anchor" href="#一般形式"></a> 一般形式</h3><p>因为可以对观测数据进行灵活的符合实际的建模（不同的概率分布假设），贝叶斯概率分解模型已经成为了最常见的矩阵/张量分解方法。其中，贝叶斯泊松分解模型一方面可以对计数值（count data）进行有效的建模，另一方面得益于其非负的分解结构，可以用于替代传统的非负矩阵分解模型（NMF），因而被广泛应用于推荐系统、因子分析和聚类分析中。常见的贝叶斯泊松矩阵分解模型如下，其中观测值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>服从泊松分布，而其分解得到的因子矩阵的值则服从共轭的Gamma分布：</p>\begin{equation}\begin{split}&x_{ij}=\sum_{k=1}^{K}z_{ijk}, z_{ijk}\sim\text{Pois}(u_{ik}v_{jk}), \\&u_{ik}\sim\text{Gamma}(a^{(u)},\frac{b^{(u)}}{a^{(u)}}),\\&v_{jk}\sim\text{Gamma}(a^{(v)},\frac{b^{(v)}}{a^{(v)}}).\\\end{split}\end{equation}<a id="more"></a><p>其中Gamma分布的概率密度函数如下所示，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>∈</mo><msub><mi mathvariant="double-struck">R</mi><mo>+</mo></msub></mrow><annotation encoding="application/x-tex">\alpha\in\mathbb{R}_{+}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897221em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>为shape参数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi><mo>∈</mo><msub><mi mathvariant="double-struck">R</mi><mo>+</mo></msub></mrow><annotation encoding="application/x-tex">\beta\in\mathbb{R}_{+}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897221em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>为scale参数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>=</mo><mi>n</mi><mo>!</mo></mrow><annotation encoding="application/x-tex">\Gamma(n+1)=n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span>为gamma函数：</p>\begin{equation}\text{Gamma}(x;\alpha,\beta)=\text{exp}\left((\alpha-1)\text{ln}x-\frac{x}{\beta}-\text{ln}\Gamma(\alpha)-\alpha\text{ln}\beta\right)\end{equation}<h3 id="binary形式"><a class="markdownIt-Anchor" href="#binary形式"></a> Binary形式</h3><h2 id="变分推断"><a class="markdownIt-Anchor" href="#变分推断"></a> 变分推断</h2><h3 id="变分更新公式"><a class="markdownIt-Anchor" href="#变分更新公式"></a> 变分更新公式</h3><p>上述模型的联合概率分布函数为</p>\begin{equation}p(X,Z,U,V)=p(X\mid Z)p(Z\mid U,V)p(U)p(V)\end{equation}<p>其对数形式展开如下</p>\begin{equation}\begin{split}\text{ln}p(X,Z,U,V)=&\sum_{i}\sum_{j}\sum_{k}\left(-u_{ik}v_{jk}+z_{ijk}\text{ln}(u_{ik}v_{jk})-\text{ln}\Gamma(z_{ijk}+1)\right) \\&+\sum_{i}\sum_{j}\left((a^{(u)}-1)\text{ln}u_{ik}-\frac{a^{(u)}}{b^{(u)}}u_{ik}-\text{ln}\Gamma(a^{(u)})-a^{(u)}\text{ln}\frac{b^{(u)}}{a^{(u)}}\right) \\&+\sum_{i}\sum_{j}\left((a^{(v)}-1)\text{ln}v_{jk}-\frac{a^{(v)}}{b^{(v)}}v_{jk}-\text{ln}\Gamma(a^{(v)})-a^{(v)}\text{ln}\frac{b^{(v)}}{a^{(v)}}\right) \\\end{split}\end{equation}<p>与此同时，对后验概率分布的变分近似分布进行分解，得到</p>\begin{equation}\begin{split}q(Z,U,V)&=q(Z)q(U)q(V) \\&=\prod_{i,j}q_{\boldsymbol{z}_{ij}}(\boldsymbol{z}_{ij})\prod_{i,k}q_{u_{ik}}(u_{ik})\prod_{j,k}q_{v_{jk}}(v_{jk})\end{split}\end{equation}<p>根据<a href="https://yxnchen.github.io/machine-learning/%E5%8F%98%E5%88%86%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%8E%A8%E6%96%AD%E7%AC%94%E8%AE%B0/">变分贝叶斯推断笔记</a>中的公式(3)，我们可以对各个因子的最优化形式进行推导。首先，对于因子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><msub><mi mathvariant="bold-italic">z</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></msub><mo>(</mo><msub><mi mathvariant="bold-italic">z</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">q_{\boldsymbol{z}_{ij}}(\boldsymbol{z}_{ij})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0973199999999999em;vertical-align:-0.34731999999999996em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16110800000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord boldsymbol mtight" style="margin-right:0.04213em;">z</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34731999999999996em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.04213em;">z</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，有</p>\begin{equation}\begin{split}\text{ln}q_{\boldsymbol{z}_{ij}}^{*}(\boldsymbol{z}_{ij})&=\mathbb{E}_{(\Theta\backslash \boldsymbol{z}_{ij})}[\text{ln}p(X,Z,U,V)]+\text{const} \\&=\mathbb{E}_{(\Theta\backslash \boldsymbol{z}_{ij})}\left[\sum_{k}\left(-\text{ln}\Gamma(z_{ijk}+1)+z_{ijk}\left(\text{ln}u_{ik}+\text{ln}v_{jk}\right)\right)\right]+\text{const} \\&=\sum_{k}\left(-\text{ln}\Gamma(z_{ijk}+1)+z_{ijk}\left(\mathbb{E}[\text{ln}u_{ik}]+\mathbb{E}[\text{ln}v_{jk}]\right)\right)+\text{const} \\&=\sum_{k}\left(-\text{ln}\Gamma(z_{ijk}+1)+z_{ijk}\text{ln}e^{\mathbb{E}[\text{ln}u_{ik}]+\mathbb{E}[\text{ln}v_{jk}]}\right)+\text{const} \\\end{split}\end{equation}<p>辅助变量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold-italic">z</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\boldsymbol{z}_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.730548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.04213em;">z</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的后验为多项式分布，其参数为</p>\begin{equation}\phi_{ijk}^{*}=\frac{e^{\mathbb{E}[\text{ln}u_{ik}]+\mathbb{E}[\text{ln}v_{jk}]}}{\sum_{k}e^{\mathbb{E}[\text{ln}u_{ik}]+\mathbb{E}[\text{ln}v_{jk}]}}\end{equation}<p>因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mrow><mi>i</mi><mi>j</mi><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">z_{ijk}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的更新公式为</p>\begin{equation}\mathbb{E}[z_{ijk}]=x_{ij}\phi_{ijk}^{*}\end{equation}<p>进一步地，对于因子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><msub><mi>u</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub></msub><mo>(</mo><msub><mi>u</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">q_{u_{ik}}(u_{ik})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00586em;vertical-align:-0.25586em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.55em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25586em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，有</p>\begin{equation}\begin{split}\text{ln}q_{u_{ik}}^{*}(u_{ik})&=\mathbb{E}_{(\Theta\backslash u_{ik})}[\text{ln}p(X,Z,U,V)]+\text{const} \\&=\mathbb{E}_{(\Theta\backslash u_{ik})}\left[\left(a^{(u)}+\sum_{j}z_{ijk}-1\right)\text{ln}u_{ik}-\left(\frac{a^{(u)}}{b^{(u)}}+\sum_{k}v_{jk}\right)u_{ik}\right]+\text{const} \\&=\left(a^{(u)}+\sum_{j}\mathbb{E}[z_{ijk}]-1\right)\text{ln}u_{ik}-\left(\frac{a^{(u)}}{b^{(u)}}+\sum_{k}\mathbb{E}[v_{jk}]\right)u_{ik}+\text{const} \\\end{split}\end{equation}<p>由共轭性，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><msub><mi>u</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub></msub><mo>(</mo><msub><mi>u</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">q_{u_{ik}}(u_{ik})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00586em;vertical-align:-0.25586em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.55em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25586em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>仍然是Gamma分布，其参数为</p>\begin{equation}\begin{split}\alpha_{ik}^{(u)*}&=a^{(u)}+\sum_{j}\mathbb{E}[z_{ijk}],\\\beta_{ik}^{(u)*}&=\left(\frac{a^{(u)}}{b^{(u)}}+\sum_{k}\mathbb{E}[v_{jk}]\right)^{-1},\\\end{split}\end{equation}<p>因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">u_{ik}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的更新公式为</p>\begin{equation}\begin{split}\mathbb{E}[u_{ik}]&=\alpha_{ik}^{(u)*}\beta_{ik}^{(u)*} \\\mathbb{E}[\text{ln}u_{ik}]&=\psi(\alpha_{ik}^{(u)*})+\text{ln}\beta_{ik}^{(u)*}\end{split}\end{equation}<p>最后，因子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><msub><mi>v</mi><mrow><mi>j</mi><mi>k</mi></mrow></msub></msub><mo>(</mo><msub><mi>v</mi><mrow><mi>j</mi><mi>k</mi></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">q_{v_{jk}}(v_{jk})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1030799999999998em;vertical-align:-0.35307999999999995em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35307999999999995em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的计算与因子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><msub><mi>u</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub></msub><mo>(</mo><msub><mi>u</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">q_{u_{ik}}(u_{ik})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00586em;vertical-align:-0.25586em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.55em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25586em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>类似。</p><h3 id="变分下界计算"><a class="markdownIt-Anchor" href="#变分下界计算"></a> 变分下界计算</h3><p>变分下界的计算公式如下：</p>\begin{equation}\begin{split}\mathcal{L}(q)&=\mathbb{E}_{q}[\text{ln}p(X,\Theta)]+H(q(\Theta))\end{split}\end{equation}<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>(</mo><mi>q</mi><mo>(</mo><mi mathvariant="normal">Θ</mi><mo>)</mo><mo>)</mo><mo>=</mo><mo>−</mo><msub><mi mathvariant="double-struck">E</mi><mi>q</mi></msub><mo>[</mo><mtext>ln</mtext><mi>q</mi><mo>(</mo><mi mathvariant="normal">Θ</mi><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">H(q(\Theta))=-\mathbb{E}_{q}[\text{ln}q(\Theta)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord">Θ</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord">−</span><span class="mord"><span class="mord"><span class="mord mathbb">E</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord text"><span class="mord">ln</span></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord">Θ</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span>，因此我们可以计算变分下界，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo>∑</mo><mi>i</mi></msub><msub><mo>∑</mo><mi>j</mi></msub><msub><mo>∑</mo><mi>k</mi></msub><mi mathvariant="double-struck">E</mi><mrow><mo fence="true">[</mo><mtext>ln</mtext><mi mathvariant="normal">Γ</mi><mo>(</mo><msub><mi>z</mi><mrow><mi>i</mi><mi>j</mi><mi>k</mi></mrow></msub><mo>+</mo><mn>1</mn><mo>)</mo><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_{i}\sum_{j}\sum_{k}\mathbb{E}\left[\text{ln}\Gamma(z_{ijk}+1)\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1863979999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbb">E</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord text"><span class="mord">ln</span></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>项可以在计算过程中消去</p>\begin{equation}\begin{split}\mathcal{L}(q)=&-\sum_{i}\sum_{j}\sum_{k}\mathbb{E}[u_{ik}]\mathbb{E}[v_{jk}] \\&+\sum_{i}\sum_{k}\mathbb{E}[\text{ln}u_{ik}]\left(a^{(u)}-1+\sum_{j}\mathbb{E}[z_{ijk}]\right) \\&+\sum_{j}\sum_{k}\mathbb{E}[\text{ln}v_{jk}]\left(a^{(v)}-1+\sum_{i}\mathbb{E}[z_{ijk}]\right) \\&+\sum_{i}\sum_{k}\left(-\frac{a^{(u)}}{b^{(u)}}\mathbb{E}[u_{ik}]-\text{ln}\Gamma(a^{(u)})-a^{(u)}\text{ln}\frac{b^{(u)}}{a^{(u)}}\right) \\&+\sum_{j}\sum_{k}\left(-\frac{a^{(v)}}{b^{(v)}}\mathbb{E}[v_{jk}]-\text{ln}\Gamma(a^{(v)})-a^{(v)}\text{ln}\frac{b^{(v)}}{a^{(v)}}\right) \\&+\sum_{i}\sum_{j}\left(-\text{ln}\Gamma(x_{ij}+1)-\sum_{k}\mathbb{E}[z_{ijk}]\text{ln}\phi_{ijk}^{*}\right) \\&+\sum_{i}\sum_{k}\left(-(\alpha_{ik}^{(u)*}-1)\psi(\alpha_{ik}^{(u)*})+\text{ln}\beta_{ik}^{(u)*}+\alpha_{ik}^{(u)*}+\text{ln}\Gamma(\alpha_{ik}^{(u)*})\right) \\&+\sum_{j}\sum_{k}\left(-(\alpha_{jk}^{(v)*}-1)\psi(\alpha_{jk}^{(v)*})+\text{ln}\beta_{jk}^{(v)*}+\alpha_{jk}^{(v)*}+\text{ln}\Gamma(\alpha_{jk}^{(v)*})\right) \\\end{split}\end{equation}<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ol><li>Prem Gopalan, Jake M. Hofman, David M. Blei. “Scalable recommendation with hierarchical poisson factorization”. In <em>UAI</em>, 2015.</li></ol>]]></content>
      
      
      <categories>
          
          <category> research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Bayesian </tag>
            
            <tag> Variational Inference </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变分贝叶斯推断笔记</title>
      <link href="/research/%E5%8F%98%E5%88%86%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%8E%A8%E6%96%AD%E7%AC%94%E8%AE%B0/"/>
      <url>/research/%E5%8F%98%E5%88%86%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%8E%A8%E6%96%AD%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="变分贝叶斯推断"><a class="markdownIt-Anchor" href="#变分贝叶斯推断"></a> 变分贝叶斯推断</h2><h3 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h3><p>假设当前有一个贝叶斯模型，且其中的参数都有相应的先验分布。同时，模型中还可能有潜变量，将其与各种参数标记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">\Theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Θ</span></span></span></span>。同样地，把所有观测变量集合标记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">Y</mi></mrow><annotation encoding="application/x-tex">\mathcal{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78055em;vertical-align:-0.09722em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">Y</span></span></span></span></span>。因此，我们希望找到分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>(</mo><mi mathvariant="normal">Θ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">q(\Theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord">Θ</span><span class="mclose">)</span></span></span></span>来逼近真实后验分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi mathvariant="normal">Θ</mi><mo>∣</mo><mi mathvariant="script">Y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p(\Theta\mid\mathcal{Y})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">Θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">Y</span></span><span class="mclose">)</span></span></span></span>，而这可以通过最小化KL散度实现，也即：</p>\begin{equation}\begin{split}\text{KL}(q(\Theta)\|p(\Theta|\mathcal{Y}))&=\int q(\Theta)\text{ln}\left\{\frac{q(\Theta)}{p(\Theta\mid\mathcal{Y})}\right\}d\Theta \\&=\text{ln}p(\mathcal{Y})-\int q(\Theta)\text{ln}\left\{\frac{p(\mathcal{Y},\Theta)}{q(\Theta)}\right\}d\Theta\end{split}\end{equation}<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>ln</mtext><mi>p</mi><mo>(</mo><mi mathvariant="script">Y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\text{ln}p(\mathcal{Y})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">ln</span></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">Y</span></span><span class="mclose">)</span></span></span></span>表示模型证据（Evidence），则其下界（lower bound）可以定义为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">L</mi><mo>(</mo><mi>q</mi><mo>)</mo><mo>=</mo><mo>∫</mo><mi>q</mi><mo>(</mo><mi mathvariant="normal">Θ</mi><mo>)</mo><mtext>ln</mtext><mo>{</mo><mfrac><mrow><mi>p</mi><mo>(</mo><mi mathvariant="script">Y</mi><mo separator="true">,</mo><mi mathvariant="normal">Θ</mi><mo>)</mo></mrow><mrow><mi>q</mi><mo>(</mo><mi mathvariant="normal">Θ</mi><mo>)</mo></mrow></mfrac><mo>}</mo><mi>d</mi><mi mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">\mathcal{L}(q)=\int q(\Theta)\text{ln}\{\frac{p(\mathcal{Y},\Theta)}{q(\Theta)}\}d\Theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal">L</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord">Θ</span><span class="mclose">)</span><span class="mord text"><span class="mord">ln</span></span><span class="mopen">{</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="mopen mtight">(</span><span class="mord mtight">Θ</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.08222em;">Y</span></span><span class="mpunct mtight">,</span><span class="mord mtight">Θ</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">}</span><span class="mord mathdefault">d</span><span class="mord">Θ</span></span></span></span>。因为模型证据是一个常量，当KL散度为0时，下界出现最大值，这就意味着<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>(</mo><mi mathvariant="normal">Θ</mi><mo>)</mo><mo>=</mo><mi>p</mi><mo>(</mo><mi mathvariant="script">Y</mi><mo separator="true">,</mo><mi mathvariant="normal">Θ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">q(\Theta)=p(\mathcal{Y},\Theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord">Θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">Y</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Θ</span><span class="mclose">)</span></span></span></span>。</p><a id="more"></a><h3 id="平均场理论"><a class="markdownIt-Anchor" href="#平均场理论"></a> 平均场理论</h3><p>根据平均场理论（mean field theory），我们假设变分分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>(</mo><mi mathvariant="normal">Θ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">q(\Theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord">Θ</span><span class="mclose">)</span></span></span></span>可以被分解成各组变量分布的乘积，即可以写作：</p>\begin{equation}q(\Theta)=\prod_{j}^{M}q_j(\Theta_j)\end{equation}<p>这是针对该分布的唯一假设，其中每一个独立因子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><mi>j</mi></msub><mo>(</mo><msub><mi mathvariant="normal">Θ</mi><mi>j</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">q_j(\Theta_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord">Θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的特定函数形式可以具体地一个个推导出来。通过最大化下届<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">L</mi><mo>(</mo><mi>q</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{L}(q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal">L</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span>，第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>个因子的优化形式由下式给出：</p>\begin{equation}\text{ln}q_j(\Theta_j)=\mathbb{E}_{q(\Theta\backslash\Theta_j)}\left[\text{ln}p(\mathcal{Y},\Theta)\right]+\text{const}\end{equation}<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="double-struck">E</mi><mrow><mi>q</mi><mo>(</mo><mi mathvariant="normal">Θ</mi><mi mathvariant="normal">\</mi><msub><mi mathvariant="normal">Θ</mi><mi>j</mi></msub><mo>)</mo></mrow></msub><mrow><mo fence="true">[</mo><mo>⋅</mo><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbb{E}_{q(\Theta\backslash\Theta_j)}\left[\cdot\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1275199999999999em;vertical-align:-0.3775199999999999em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">E</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34479999999999994em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="mopen mtight">(</span><span class="mord mtight">Θ</span><span class="mord mtight">\</span><span class="mord mtight"><span class="mord mtight">Θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3775199999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">⋅</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>表示关于除<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Θ</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\Theta_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord">Θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>外所有变量的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>分布的期望。因为所有参数的分布都属于指数族分布，且都与其父节点共轭，因此我们能够通过公式(3)推导出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">\Theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Θ</span></span></span></span>中每个参数的后验分布更新的近似形式。</p><h3 id="变分下界"><a class="markdownIt-Anchor" href="#变分下界"></a> 变分下界</h3><p>在模型计算时，可以通过直接计算变分下界<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">L</mi><mo>(</mo><mi>q</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{L}(q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal">L</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span>来判断算法是否收敛，因为在每一次迭代中变分下界不减。变分下界可以通过下式进行计算</p>\begin{equation}\begin{split}\mathcal{L}(q)&=\int q(\Theta)\text{ln}\left\{\frac{p(\mathcal{Y},\Theta)}{p(\Theta)}\right\}d\Theta \\&=\mathbb{E}_{q}[\text{ln}p(\mathcal{Y},\Theta)]-\mathbb{E}_{q}[\text{ln}q(\Theta)] \\&=\mathbb{E}_{q}[\text{ln}p(\mathcal{Y}\mid\Theta)]+\mathbb{E}_{q}[\text{ln}p(\Theta)]-\sum_{j}\mathbb{E}_{q_j(\Theta_j)}[\text{ln}q_j(\Theta_j)]\end{split}\end{equation}<p>其中第一项表示联合分布的后验期望，而第二项则表示后验<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>分布的熵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>(</mo><mi>q</mi><mo>(</mo><mi mathvariant="normal">Θ</mi><mo>)</mo><mo>)</mo><mo>=</mo><mo>−</mo><msub><mi mathvariant="double-struck">E</mi><mi>q</mi></msub><mo>[</mo><mtext>ln</mtext><mi>p</mi><mo>(</mo><mi>q</mi><mo>(</mo><mi mathvariant="normal">Θ</mi><mo>)</mo><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">H(q(\Theta))=-\mathbb{E}_{q}[\text{ln}p(q(\Theta))]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord">Θ</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord">−</span><span class="mord"><span class="mord"><span class="mord mathbb">E</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord text"><span class="mord">ln</span></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord">Θ</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span>。</p><h2 id="例子-一元高斯模型"><a class="markdownIt-Anchor" href="#例子-一元高斯模型"></a> 例子-一元高斯模型</h2><h3 id="模型推断"><a class="markdownIt-Anchor" href="#模型推断"></a> 模型推断</h3><p>给定一组观测数据值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">D</mi><mo>=</mo><mo>{</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>N</mi></msub><mo>}</mo></mrow><annotation encoding="application/x-tex">\mathcal{D}=\{x_1,x_2,\dots,x_N\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，假定数据是独立地从高斯分布中抽取的，目标是通过最大化后验分布推断得到均值参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>和精度参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>，其似然函数为</p>\begin{equation}\begin{split}p(\mathcal{D}\mid \mu,\tau)&=\prod_{i=1}^{N}\left(\frac{\tau}{2\pi}\right)^{\frac{1}{2}}\text{exp}\left\{-\frac{\tau(x_i-\mu)^2}{2}\right\} \\&=\left(\frac{\tau}{2\pi}\right)^{\frac{N}{2}}\text{exp}\left\{-\frac{\tau}{2}\sum_{i=1}^{N}(x_i-\mu)^2\right\}\end{split}\end{equation}<p>同时引入参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>的共轭先验分布，其形式为</p>\begin{equation}\begin{split}p(\mu\mid\tau)&= \mathcal{N}(\mu\mid\mu_{0},\left[\lambda_{0}\tau\right]^{-1})\\p(\tau)&= \text{Gam}(\tau\mid a_0,b_0)\end{split}\end{equation}<p>则其联合分布可以表示为</p>\begin{equation}\begin{split}p(\mathcal{D},\mu,\tau)=p(\mathcal{D}\mid\mu,\tau)p(\mu\mid\tau)p(\tau)\end{split}\end{equation}<p>对后验概率分布的变分近似进行分解</p>\begin{equation}q(\mu,\tau)=q_{\mu}(\mu)q_{\tau}(\tau)\end{equation}<p>根据公式(3)，可以推导出各个因子的优化形式，对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><mi>μ</mi></msub><mo>(</mo><mi>μ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">q_{\mu}(\mu)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">μ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">μ</span><span class="mclose">)</span></span></span></span>，我们有</p>\begin{equation}\begin{split}\text{ln}q_{\mu}^{*}(\mu)&=\mathbb{E}_{\tau}[\text{ln}p(\mathcal{D}\mid\mu,\tau)+\text{ln}p(\mu\mid\tau)]+\text{const} \\&=-\frac{\mathbb{E}[\tau]}{2}\left\{\sum_{i=1}^{N}(x_i-\mu)^2+\lambda_0(\mu-\mu_0)^2\right\}+\text{const} \\&=-\frac{1}{2}\left\{(\lambda_0+N)\mathbb{E}[\tau]\mu^2-2(\lambda_0\mu_0+N\bar{x})\mathbb{E}[\tau]\mu\right\}+\text{const}\end{split}\end{equation}<p>由共轭性，可以看到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><mi>μ</mi></msub><mo>(</mo><mi>μ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">q_{\mu}(\mu)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">μ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">μ</span><span class="mclose">)</span></span></span></span>是一个高斯分布，其参数为</p>\begin{equation}\begin{split}\lambda^{*}&=(\lambda_0+N)\mathbb{E}[\tau] \\\mu^{*}&=[\lambda^*]^{-1}(\lambda_0\mu_0+N\bar{x})\mathbb{E}[\tau] =\frac{\lambda_0\mu_0+N\bar{x}}{\lambda_0+N}\end{split}\end{equation}<p>同理，因子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><mi>τ</mi></msub><mo>(</mo><mi>τ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">q_{\tau}(\tau)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.1132em;">τ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mclose">)</span></span></span></span>的最优形式为</p>\begin{equation}\begin{split}\text{ln}q_{\tau}^{*}(\tau)&=\mathbb{E}_{\mu}[\text{ln}p(\mathcal{D}\mid\mu,\tau)+\text{ln}p(\mu\mid\tau)+\text{ln}p(\tau)]+\text{const} \\&=(a_0-1+\frac{N+1}{2})\text{ln}\tau-\left\{b_0+\frac{1}{2}\mathbb{E}\mu\left[\sum_{i=1}^{N}(x_i-\mu)^2+\lambda_0(\mu-\mu_0)^2\right]\right\}\tau+\text{const}\end{split}\end{equation}<p>因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><mi>τ</mi></msub><mo>(</mo><mi>τ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">q_{\tau}(\tau)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.1132em;">τ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mclose">)</span></span></span></span>是一个Gamma分布，参数为</p>\begin{equation}\begin{split}a^{*}&=a_0+\frac{N+1}{2} \\b^{*}&=b_0+\frac{1}{2}\mathbb{E}\mu\left[\sum_{i=1}^{N}(x_i-\mu)^2+\lambda_0(\mu-\mu_0)^2\right]\end{split}\end{equation}<p>为了评估模型的收敛性，我们进一步计算变分下界，其公式如下</p>\begin{equation}\begin{split}\mathcal{L}(q)&=\mathbb{E}_{q}[\text{ln}p(\mathcal{Y},\Theta)]-\mathbb{E}_{q}[\text{ln}q(\Theta)] \\&=\mathbb{E}_{q(\mu,\tau)}[\text{ln}p(\mathcal{D}\mid\mu,\tau)]+\mathbb{E}_{q(\mu,\tau)}[\text{ln}p(\mu\mid\tau)]+\mathbb{E}_{q(\tau)}[\text{ln}p(\tau)]-\mathbb{E}_{q(\mu)}[\text{ln}q(\mu)]-\mathbb{E}_{q(\tau)}[\text{ln}q(\tau)]\end{split}\end{equation}<p>上式各个部分可以通过下面公式计算得到，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="double-struck">E</mi><mi>q</mi></msub><mo>[</mo><msup><mi>μ</mi><mn>2</mn></msup><mo>]</mo><mo>=</mo><msub><mi mathvariant="double-struck">E</mi><mi>μ</mi></msub><mo>[</mo><msup><mi>μ</mi><mn>2</mn></msup><mo>]</mo><mo>=</mo><mo>(</mo><mi mathvariant="double-struck">E</mi><mo>[</mo><mi>μ</mi><mo>]</mo><msup><mo>)</mo><mn>2</mn></msup><mo>+</mo><mtext>Var</mtext><mo>[</mo><mi>μ</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\mathbb{E}_q[\mu^2]=\mathbb{E}_{\mu}[\mu^2]=(\mathbb{E}[\mu])^2+\text{Var}[\mu]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1002159999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">E</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1002159999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">E</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">μ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathbb">E</span></span><span class="mopen">[</span><span class="mord mathdefault">μ</span><span class="mclose">]</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Var</span></span><span class="mopen">[</span><span class="mord mathdefault">μ</span><span class="mclose">]</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="double-struck">E</mi><mi>q</mi></msub><mo>[</mo><mtext>ln</mtext><mi>τ</mi><mo>]</mo><mo>=</mo><msub><mi mathvariant="double-struck">E</mi><mi>τ</mi></msub><mo>[</mo><mtext>ln</mtext><mi>τ</mi><mo>]</mo><mo>=</mo><mi>ψ</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>−</mo><mtext>ln</mtext><mi>b</mi></mrow><annotation encoding="application/x-tex">\mathbb{E}_q[\text{ln}\tau]=\mathbb{E}_{\tau}[\text{ln}\tau]=\psi(a)-\text{ln}b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">E</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord text"><span class="mord">ln</span></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">E</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.1132em;">τ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord text"><span class="mord">ln</span></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">ln</span></span><span class="mord mathdefault">b</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ψ</mi><mo>(</mo><mo>⋅</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\psi(\cdot)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord">⋅</span><span class="mclose">)</span></span></span></span>为双伽马函数（digamma function）而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi><mo>(</mo><mo>⋅</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\Gamma(\cdot)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord">⋅</span><span class="mclose">)</span></span></span></span>为伽马函数。</p>\begin{equation}\begin{split}\mathbb{E}_{q}[\text{ln}p(\mathcal{D}\mid\mu,\tau)]&=-\frac{N}{2}\text{ln}(2\pi)+\frac{N}{2}\mathbb{E}_q[\text{ln}\tau]-\frac{1}{2}\mathbb{E}_q[\tau]\mathbb{E}_q[\sum_{i=1}^{N}(x_i-\mu)^2] \\&=-\frac{N}{2}\text{ln}(2\pi)+\frac{N}{2}(\psi(a^*)-\text{ln}(b^*))-\frac{a^*}{2b^*}\left\{\sum_{i=1}^{N}x_i^2-2\mu^*\sum_{i=1}^{N}x_i+\mathbb{E}_q[\mu^2]\right\} \\\end{split}\end{equation}\begin{equation}\begin{split}\mathbb{E}_{q}[\text{ln}p(\mu\mid\tau)]&=-\frac{1}{2}\text{ln}(2\pi)+\frac{1}{2}\mathbb{E}_q[\text{ln}(\lambda_0\tau)]-\frac{\lambda_0}{2}\mathbb{E}_q[\tau]\mathbb{E}_q[(\mu-\mu_0)^2] \\&=-\frac{1}{2}\text{ln}(2\pi)+\frac{\text{ln}\lambda_0}{2}+\frac{1}{2}(\psi(a^*)-\text{ln}(b^*))-\frac{\lambda_0 a^*}{2b^*}\left\{\mathbb{E}_q[\mu^2]-2\mu_0\mu^*+\mu_0^2\right\} \\\end{split}\end{equation}\begin{equation}\begin{split}\mathbb{E}_{q}[\text{ln}p(\tau)]&=-\text{ln}\Gamma(a_0)+a_0\text{ln}b_0+(a_0-1)\mathbb{E}_q[\text{ln}\tau]-b_0\mathbb{E}_q[\tau] \\&=-\text{ln}\Gamma(a_0)+a_0\text{ln}b_0+(a_0-1)(\psi(a^*)-\text{ln}b^*)-b_0\frac{a^*}{b^*}\end{split}\end{equation}\begin{equation}\begin{split}-\mathbb{E}_{q}[\text{ln}q(\mu)]&=\frac{1}{2}\text{ln}(2\pi)-\frac{\text{ln}\lambda^*}{2}+\frac{\lambda^*}{2}\left\{\mathbb{E}_q[\mu^2]-2(\mu^*)^2+(\mu^*)^2\right\} \\&=\frac{1}{2}\text{ln}(2\pi)-\frac{\text{ln}\lambda^*}{2}+\frac{1}{2}\end{split}\end{equation}\begin{equation}\begin{split}-\mathbb{E}_{q}[\text{ln}q(\tau)]&=\text{ln}\Gamma(a^*)-(a^*-1)\psi(a^*)-\text{ln}b^*+a^*\end{split}\end{equation}<p>至此，我们得到了关于参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>最优分布的表达式，且各自依赖于另一个分布的计算所得的一阶矩或二阶矩。因此通过初始化参数的值，可以通过不断迭代计算出后验分布。</p><p>在此例子中，由于模型简单且参数数量只有两个，因此我们可以通过直接求解上式的因子找到显示解。首先我们可以通过设置无信息先验（noninformative prior）来简化上述表达式，也即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>μ</mi><mn>0</mn></msub><mo>=</mo><msub><mi>λ</mi><mn>0</mn></msub><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>=</mo><msub><mi>b</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mu_0=\lambda_0=a_0=b_0=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。根据Gamma分布的均值计算公式，我们有</p>\begin{equation}\begin{split}\frac{1}{\mathbb{E}[\tau]}=\frac{b^*}{a^*}=\mathbb{E}\left[\frac{1}{N+1}\sum_{i=1}^{N}(x_i-\mu)^2\right]=\frac{N}{N+1}(\overline{x^{2}}-2\bar{x}\mathbb{E}[\mu]+\mathbb{E}[\mu^2])\end{split}\end{equation}<p>由公式(10)，我们可以获得近似分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><mi>μ</mi></msub><mo>(</mo><mi>μ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">q_\mu(\mu)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">μ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">μ</span><span class="mclose">)</span></span></span></span>的一阶矩与二阶矩</p>\begin{equation}\begin{split}\mathbb{E}[\mu]=\bar{x}, \mathbb{E}[\mu^2]=\bar{x}^2+\frac{1}{N\mathbb{E}[\tau]}\end{split}\end{equation}<p>将其代入公式(19)，可以解出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="double-struck">E</mi><mo>[</mo><mi>τ</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\mathbb{E}[\tau]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">E</span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mclose">]</span></span></span></span></p>\begin{equation}\frac{1}{\mathbb{E}[\tau]}=\overline{x^2}-\bar{x}^2\end{equation}=\frac{1}{N}\sum_{i=1}^{N}(x_i-\bar{x})^2<h3 id="代码示例"><a class="markdownIt-Anchor" href="#代码示例"></a> 代码示例</h3><p>上节一元高斯的求解MATLAB代码如下所示，首先通过随机数生成器生成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个高斯分布的随机数作为模型观测值</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear;</span><br><span class="line"><span class="comment">% 生成高斯分布随机数</span></span><br><span class="line">mu_real = <span class="number">1</span>;</span><br><span class="line">tau_real = <span class="number">1.5</span>;</span><br><span class="line">N = <span class="number">200</span>;</span><br><span class="line">D = normrnd(mu_real, <span class="built_in">sqrt</span>(<span class="number">1.</span>/tau_real), [N,<span class="number">1</span>]);</span><br><span class="line">sumD = sum(D);</span><br><span class="line">sumD2 = sum(D.^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">mu_est = mean(D); <span class="comment">% 公式(20)</span></span><br><span class="line">tau_est = <span class="number">1.</span>/(mean(D.^<span class="number">2</span>)-mean(D).^<span class="number">2</span>); <span class="comment">% 公式(21)</span></span><br><span class="line"><span class="comment">% 查看该一元高斯的分布图像</span></span><br><span class="line">x_real=<span class="number">-4</span>+mu_real:<span class="number">0.1</span>:mu_real+<span class="number">4</span>;</span><br><span class="line">y_real=normpdf(x_real,mu_real,<span class="built_in">sqrt</span>(<span class="number">1.</span>/tau_real));</span><br><span class="line">x_est=<span class="number">-4</span>+mu_est:<span class="number">0.1</span>:mu_est+<span class="number">4</span>;</span><br><span class="line">y_est=normpdf(x_est,mu_est,<span class="built_in">sqrt</span>(<span class="number">1.</span>/tau_est));</span><br><span class="line">figure;plot(x_real,y_real,<span class="string">'-r.'</span>,x_est,y_est,<span class="string">'--b.'</span>);grid;</span><br></pre></td></tr></table></figure><p>初始化模型参数和超参数</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 初始化参数和超参数</span></span><br><span class="line">mu0 = <span class="number">1e-6</span>; <span class="comment">% 无信息先验</span></span><br><span class="line">lambda0 = <span class="number">1e-6</span>; <span class="comment">% 无信息先验</span></span><br><span class="line">a0 = <span class="number">1e-6</span>; <span class="comment">% 无信息先验</span></span><br><span class="line">b0 = <span class="number">1e-6</span>; <span class="comment">% 无信息先验</span></span><br><span class="line">mu = <span class="built_in">randn</span>();</span><br><span class="line">mus(<span class="number">1</span>) = mu;</span><br><span class="line">tau = <span class="built_in">rand</span>();</span><br><span class="line">taus(<span class="number">1</span>) = tau;</span><br><span class="line"></span><br><span class="line">LB = <span class="number">0</span>; <span class="comment">% 变分下界</span></span><br><span class="line">tol = <span class="number">1e-5</span>; <span class="comment">% 收敛允许误差</span></span><br><span class="line">maxiters = <span class="number">100</span>; <span class="comment">% 迭代最大次数</span></span><br></pre></td></tr></table></figure><p>可视化求解过程，将分别绘出模型参数的真值与估计值比较图、变分下界变化图和精度参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>的后验分布变化图</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 可视化求解过程</span></span><br><span class="line">scrnsz = get(<span class="number">0</span>,<span class="string">'ScreenSize'</span>);</span><br><span class="line">h = figure(<span class="string">'Position'</span>,[scrnsz(<span class="number">3</span>)*<span class="number">0.25</span> scrnsz(<span class="number">4</span>)*<span class="number">0.25</span> scrnsz(<span class="number">3</span>)*<span class="number">0.5</span> scrnsz(<span class="number">4</span>)*<span class="number">0.5</span>]);</span><br><span class="line">set(<span class="number">0</span>,<span class="string">'CurrentFigure'</span>,h);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>); plot(mu_real, <span class="string">'-r.'</span>,<span class="string">'LineWidth'</span>,<span class="number">1.5</span>,<span class="string">'MarkerSize'</span>,<span class="number">10</span> ); title(<span class="string">'Model parameter \mu'</span>); xlabel(<span class="string">'Iteration'</span>); grid on;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>); plot(tau_real, <span class="string">'-r.'</span>,<span class="string">'LineWidth'</span>,<span class="number">1.5</span>,<span class="string">'MarkerSize'</span>,<span class="number">10</span> ); title(<span class="string">'Model parameter \tau'</span>); xlabel(<span class="string">'Iteration'</span>); grid on;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>); plot(LB, <span class="string">'-r.'</span>,<span class="string">'LineWidth'</span>,<span class="number">1.5</span>,<span class="string">'MarkerSize'</span>,<span class="number">10</span> ); title(<span class="string">'Lower bound'</span>); xlabel(<span class="string">'Iteration'</span>); grid on;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>); plot(<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">20</span>, gampdf(<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">20</span>, a0, <span class="number">1.</span>/b0), <span class="string">'r-'</span>); title(<span class="string">'Posterior pdf'</span>); xlabel(<span class="string">'Noise precision \tau'</span>); grid on;</span><br><span class="line">set(findall(h,<span class="string">'type'</span>,<span class="string">'text'</span>),<span class="string">'fontSize'</span>,<span class="number">12</span>);</span><br><span class="line">drawnow;</span><br></pre></td></tr></table></figure><p>模型迭代求解</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 模型求解</span></span><br><span class="line"><span class="keyword">for</span> it=<span class="number">1</span>:maxiters</span><br><span class="line">    <span class="comment">% 更新参数 mu，公式(10)</span></span><br><span class="line">    lambda_new = (lambda0+N)*tau;</span><br><span class="line">    mu_new = (<span class="number">1.</span>/lambda_new)*(lambda0*mu0+sumD)*tau;</span><br><span class="line">    mu = mu_new;</span><br><span class="line">    mus(it+<span class="number">1</span>) = mu;</span><br><span class="line">    E_mu2 = mu_new^<span class="number">2</span>+<span class="number">1.</span>/lambda_new; <span class="comment">% E[mu^2]=E[mu]^2+Var[mu]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 更新参数 tau，公式(12)</span></span><br><span class="line">    a_new = a0+(N+<span class="number">1</span>)./<span class="number">2</span>;</span><br><span class="line">    b_new = b0+<span class="number">0.5</span>*(sumD2<span class="number">-2</span>*(sumD+lambda0*mu0)*mu+(N+lambda0)*E_mu2+lambda0*(mu0^<span class="number">2</span>));</span><br><span class="line">    tau = a_new./b_new;</span><br><span class="line">    taus(it+<span class="number">1</span>) = tau;</span><br><span class="line">    E_lntau = <span class="built_in">psi</span>(a_new)-safelog(b_new); <span class="comment">% E[ln(tau)]=psi(a)-ln(b)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 评估变分下界，公式(13)</span></span><br><span class="line">    E_pD = <span class="number">-0.5</span>*N*safelog(<span class="number">2</span>*<span class="built_in">pi</span>)+<span class="number">0.5</span>*N*E_lntau<span class="number">-0.5</span>*tau*(sumD2<span class="number">-2</span>*mu*sumD+E_mu2);</span><br><span class="line">    E_pmu = <span class="number">-0.5</span>*safelog(<span class="number">2</span>*<span class="built_in">pi</span>)+<span class="number">0.5</span>*E_lntau+<span class="number">0.5</span>*safelog(lambda0)<span class="number">-0.5</span>*lambda0*tau*(E_mu2<span class="number">-2</span>*mu0*mu+mu0^<span class="number">2</span>);</span><br><span class="line">    E_ptau = -safelog(<span class="built_in">gamma</span>(a0))+a0*safelog(b0)+(a0<span class="number">-1</span>)*E_lntau-b0*tau;</span><br><span class="line">    E_qmu = <span class="number">0.5</span>*safelog(<span class="number">2</span>*<span class="built_in">pi</span>)<span class="number">-0.5</span>*safelog(lambda_new)+<span class="number">0.5</span>;</span><br><span class="line">    E_qtau = safelog(<span class="built_in">gamma</span>(a_new))-(a_new<span class="number">-1</span>)*<span class="built_in">psi</span>(a_new)-safelog(b_new)+a_new;</span><br><span class="line">    LB(it) = E_pD + E_pmu + E_ptau + E_qmu + E_qtau;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 可视化求解过程</span></span><br><span class="line">    set(<span class="number">0</span>,<span class="string">'CurrentFigure'</span>,h);</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>); plot(mu_real*<span class="built_in">ones</span>(<span class="number">1</span>,it+<span class="number">1</span>), <span class="string">'-r.'</span>,<span class="string">'LineWidth'</span>,<span class="number">1.5</span>,<span class="string">'MarkerSize'</span>,<span class="number">10</span>);hold on;plot(mu_est*<span class="built_in">ones</span>(<span class="number">1</span>,it+<span class="number">1</span>), <span class="string">'--r.'</span>,<span class="string">'LineWidth'</span>,<span class="number">1.5</span>,<span class="string">'MarkerSize'</span>,<span class="number">10</span> );hold on;plot(mus, <span class="string">'-b.'</span>,<span class="string">'LineWidth'</span>,<span class="number">1.5</span>,<span class="string">'MarkerSize'</span>,<span class="number">10</span>);hold off; title(<span class="string">'Model parameter \mu'</span>); xlabel(<span class="string">'Iteration'</span>); grid on;</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>); plot(tau_real*<span class="built_in">ones</span>(<span class="number">1</span>,it+<span class="number">1</span>), <span class="string">'-r.'</span>,<span class="string">'LineWidth'</span>,<span class="number">1.5</span>,<span class="string">'MarkerSize'</span>,<span class="number">10</span>);hold on;plot(tau_est*<span class="built_in">ones</span>(<span class="number">1</span>,it+<span class="number">1</span>), <span class="string">'--r.'</span>,<span class="string">'LineWidth'</span>,<span class="number">1.5</span>,<span class="string">'MarkerSize'</span>,<span class="number">10</span> );hold on;plot(taus, <span class="string">'-b.'</span>,<span class="string">'LineWidth'</span>,<span class="number">1.5</span>,<span class="string">'MarkerSize'</span>,<span class="number">10</span>);hold off; title(<span class="string">'Model parameter \tau'</span>); xlabel(<span class="string">'Iteration'</span>); grid on;</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>); plot(LB, <span class="string">'-r.'</span>,<span class="string">'LineWidth'</span>,<span class="number">1.5</span>,<span class="string">'MarkerSize'</span>,<span class="number">10</span>); title(<span class="string">'Lower bound'</span>); xlabel(<span class="string">'Iteration'</span>); grid on;</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>); plot(<span class="number">0</span>:<span class="number">0.05</span>:<span class="number">2</span>*tau, gampdf(<span class="number">0</span>:<span class="number">0.05</span>:<span class="number">2</span>*tau, a_new, <span class="number">1.</span>/b_new), <span class="string">'-r.'</span>, <span class="string">'LineWidth'</span>,<span class="number">1.5</span>); title(<span class="string">'Posterior pdf'</span>); xlabel(<span class="string">'Noise precision \tau'</span>); grid on;</span><br><span class="line">    set(findall(h,<span class="string">'type'</span>,<span class="string">'text'</span>),<span class="string">'fontSize'</span>,<span class="number">12</span>);</span><br><span class="line">    drawnow;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 判断模型是否收敛</span></span><br><span class="line">    <span class="keyword">if</span> it&gt;<span class="number">3</span></span><br><span class="line">        LB_change = <span class="number">-1</span>*(LB(it) - LB(it<span class="number">-1</span>))/LB(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        LB_change = NaN;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> it&gt;<span class="number">10</span> &amp;&amp; (<span class="built_in">abs</span>(LB_change) &lt; tol)</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'Converged!'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">safelog</span><span class="params">(x)</span></span></span><br><span class="line">x(x&lt;<span class="number">1e-300</span>)=<span class="number">1e-200</span>;</span><br><span class="line">x(x&gt;<span class="number">1e300</span>)=<span class="number">1e300</span>;</span><br><span class="line">y=<span class="built_in">log</span>(x);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>求解结果如下图所示，左上与右上两图中的<strong>红色实线</strong>表示生成观测数据模型参数的真值，<strong>红色虚线</strong>表示利用观测数据显式计算得到的模型参数的估计值，<strong>蓝色实线</strong>表示利用变分推断迭代求解的参数估计值。在本例子中，由于推断公式较简单，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="double-struck">E</mi><mo>[</mo><mi>μ</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\mathbb{E}[\mu]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">E</span></span><span class="mopen">[</span><span class="mord mathdefault">μ</span><span class="mclose">]</span></span></span></span>的计算不依赖于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="double-struck">E</mi><mo>[</mo><mi>τ</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\mathbb{E}[\tau]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">E</span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mclose">]</span></span></span></span>，所以算法在第二次迭代就已经收敛到显式计算的估计值。<br><img src="https://gh-io-1257470807.cos.ap-guangzhou.myqcloud.com/result_converged_3.png" alt="Result Convergence"></p><h2 id="例子-混合高斯模型"><a class="markdownIt-Anchor" href="#例子-混合高斯模型"></a> 例子-混合高斯模型</h2><h3 id="模型推断-2"><a class="markdownIt-Anchor" href="#模型推断-2"></a> 模型推断</h3><h3 id="代码示例-2"><a class="markdownIt-Anchor" href="#代码示例-2"></a> 代码示例</h3><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ol><li>Christopher M. Bishop. “Pattern recognition and machine learning.” <em>Springer</em>, 2006.</li><li>PRML Errata 1st: <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/05/prml-errata-1st-20110921.pdf" target="_blank" rel="noopener">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/05/prml-errata-1st-20110921.pdf</a></li><li>Qibin Zhao, Liqing Zhang, and Andrzej Cichocki. “Bayesian CP factorization of incomplete tensors with automatic rank determination.” <em>IEEE transactions on pattern analysis and machine intelligence</em>, 2015.</li><li><a href="https://github.com/qbzhao/BCPF" target="_blank" rel="noopener">https://github.com/qbzhao/BCPF</a></li><li><a href="https://en.wikipedia.org/wiki/Gamma_distribution" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Gamma_distribution</a></li><li><a href="https://en.wikipedia.org/wiki/Conjugate_prior" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Conjugate_prior</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Bayesian </tag>
            
            <tag> Variational Inference </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
